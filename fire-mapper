#!/usr/bin/env python3
# See LICENSE.md
# This project uses the AGPL-3.0 with additional terms.
# **Note, especially, the Disclaimer of Information Accuracy!**

# Additional License Terms and Disclaimer
# 1. **Non-commercial use:** This project is licensed for personal, academic, or other non-commercial purposes at no cost. You may use, modify, and distribute the project under these conditions.
# 2. **Commercial use:** Commercial use of this project, including but not limited to selling, offering as a service, or integrating into paid products, requires a separate commercial license. To obtain a commercial license, please contact jaggz.h {over at} gmail.com
# 3. **Attribution:** All use of this project, whether for non-commercial or commercial purposes, must include the following attribution:
#    - A link to the original project’s GitHub repository: https://github.com/jaggzh/fire-tracker.git
#    - A link to the official website: https://github.com/jaggzh/fire-tracker/
#    - A link to the YouTube channel: https://www.youtube.com/@jaggztech
# 4. **Attribution updates:** If the original project updates its official attribution requirements, including changes to links (e.g., GitHub repository, website, YouTube channel), users must update their attributions to reflect these changes. Updates must be made within 30 days of the new attribution requirements being published, or during the next version update of their derivative works, whichever occurs first.
# 5. **Modifications:** If you modify this project, you must clearly indicate the changes made and retain all attribution requirements outlined above.
# 6. **Disclaimer of Information Accuracy:**
#    - The information generated, prepared, or output by this project may be unreliable, incorrect, incomplete, or contain bugs.
#    - This project is intended for informational purposes only and should not be relied upon for emergency response, life-saving decisions, or any critical actions.
#    - Users of this project are solely responsible for verifying the accuracy and suitability of the information for their purposes.
# 7. **Liability Disclaimer:** This project is provided “as is,” without any warranties, guarantees, or assurances of any kind, express or implied. The author is not liable for any damages, losses, or consequences arising from the use, misuse, or reliance on this project or its outputs.
# 8. **Termination of License:** Failure to comply with the terms of this license will result in the termination of your rights to use, modify, or distribute this project.

# The above + GNU AFFERO GENERAL PUBLIC LICENSE are found in LICENSE.md

#!/usr/bin/env python3
import json
import datetime
import folium
from folium.plugins import TimestampedGeoJson
import argparse

# Default values
def_days_prior = 10
def_anim_period = 'PT1H'
def_output = '/tmp/fire-anim.html'
available_periods = ['PT1H', 'P1D', 'P1Y']  # Available animation periods

# Parse command-line arguments
parser = argparse.ArgumentParser(description="Generate an animated fire perimeter map.")
parser.add_argument("-d", "--days-prior", type=int, default=def_days_prior,
                    help=f"Days prior ({def_days_prior})")
parser.add_argument("-p", "--anim-period", type=str, default=def_anim_period, choices=available_periods,
                    help=f"Animation period. Options: {', '.join(available_periods)} (default: {def_anim_period})")
parser.add_argument("-o", "--output", type=str, default=def_output,
                    help=f"Output HTML file ({def_output})")
args = parser.parse_args()

days_prior = args.days_prior
output_file = args.output
anim_period = args.anim_period

# Calculate the cutoff timestamp based on days prior
cutoff_date = datetime.datetime.now() - datetime.timedelta(days=days_prior)
cutoff_ts = cutoff_date.timestamp()

def format_time(ts_s, period):
    """Format the timestamp based on the animation period."""
    return datetime.datetime.fromtimestamp(ts_s).isoformat()
    if period == 'PT1H':
        return datetime.datetime.fromtimestamp(ts_s).isoformat()
    elif period == 'PT1D':
        return datetime.datetime.fromtimestamp(ts_s).strftime('%Y-%m-%d')
    elif period == 'P1Y':
        return datetime.datetime.fromtimestamp(ts_s).strftime('%Y')
    else:
        raise ValueError(f"Unsupported animation period: {period}")

# Load the fire perimeter data
with open("/tmp/fire-query.json") as F:
    data = json.load(F)

views = {
    'sfvalley': {
        'zoom': 11,
        'co': [34.1622, -118.3577],
        },
    'palisades': {
        'zoom': 12,
        'co': [34.1422, -118.4577],
        },
    'usa-ca-la': {
        'zoom': 10,
        'co': [34.1022, -118.1577],
        },
    'usa-ca-south': {
        'zoom': 7,
        'co': [34.1022, -118.1577],
        },
    'usa-ca-south': {
        'zoom': 6,
        'co': [34.1022, -118.1577],
        },
    }
view = views['usa-ca-south']

# Initialize the map centered near Los Angeles
base_map = folium.Map(location=view['co'], zoom_start=view['zoom'])

# Initialize variables
mxf = len(data['features'])  # Max features
fi = mxf - 1  # Start from the end
count = 0  # Counter for features processed

# Store features for animation
geojson_features = []

# Loop through features backward in time
while fi >= 0:
    feature = data['features'][fi]
    fi -= 1  # Move to the previous feature
    
    # Extract attributes and geometry
    attr = feature['attributes']
    geo = feature['geometry']
    color = 'red'

    if 'poly_DateCurrent' in attr and attr['poly_DateCurrent'] is not None:
        ts_s = attr['poly_DateCurrent'] / 1000  # Convert to seconds
    elif 'EditDate' in attr and attr['EditDate'] is not None:
        ts_s = attr['EditDate'] / 1000
        color = 'blue'
    else:
        print("No poly_DateCurrent nor EditDate. Examine feature, attr, geo, and attr['poly_DateCurrent']")
        import ipdb; ipdb.set_trace(context=7); pass
        pass

    date_str = datetime.datetime.fromtimestamp(ts_s).strftime('%Y-%m-%d %H:%M:%S')
    
    # Debug print for timestamp details
    print(f"Feature timestamp (seconds): {ts_s}, Formatted time: {format_time(ts_s, anim_period)}, Date string: {date_str}")

    # Stop if the date is before the cutoff date
    if ts_s < cutoff_ts:
        print(f"Feature timestamp {ts_s} is before cutoff {cutoff_ts}. Skipping.")
        break
    
    # Add each ring as a GeoJSON feature with timestamp
    for ring in geo['rings']:
        geojson_features.append({
            "type": "Feature",
            "geometry": {
                "type": "Polygon",
                "coordinates": [ring]
            },
            "properties": {
                "time": format_time(ts_s, anim_period),  # Add timestamp
                "style": {
                    "color": "red",
                    "fillColor": "orange",
                    "fillOpacity": 0.5
                }
            }
        })
    
    print(f"Added feature from {date_str} with mission {attr.get('mission', 'unknown')}")

# Debug print for GeoJSON features
print(f"Total GeoJSON features added: {len(geojson_features)}")

# Create a TimestampedGeoJson layer
try:
    timestamped_geojson = TimestampedGeoJson({
        "type": "FeatureCollection",
        "features": geojson_features
    }, period=anim_period, add_last_point=True)
except Exception as e:
    print(f"Error creating TimestampedGeoJson: {e}")
    import ipdb; ipdb.set_trace(context=7); pass
    pass

# Add the animation layer to the map
timestamped_geojson.add_to(base_map)

# Save the map to an HTML file
base_map.save(output_file)
print(f"Map saved as {output_file}")
